/**
 * Export DialogueTree to Yarn Spinner source format
 * 
 * This generates valid Yarn Spinner 2.x syntax with:
 * - Stable line IDs (#line: tags)
 * - Proper <<if>>/<<elseif>>/<<else>>/<<endif>> blocks
 * - <<set>> variable commands
 * - <<jump>> navigation
 * - Choice syntax with conditions
 */

import type { DialogueTree, DialogueNode, Choice, ConditionalBlock } from '@magicborn/dialogue-forge';
import { ensureLineIds, type LineIdOptions } from './ensureLineIds';
import { createSourceMap, updateSourceMapWithYarnLines, type SourceMap } from './sourceMap';

export interface ExportOptions extends LineIdOptions {
  /** Include line ID tags in output (default: true) */
  includeLineIds?: boolean;
  /** Include source comments (default: false) */
  includeComments?: boolean;
  /** Indent string (default: '    ') */
  indent?: string;
}

export interface ExportResult {
  yarnSource: string;
  sourceMap: SourceMap;
  lineCount: number;
}

/**
 * Convert a condition array to Yarn syntax
 */
function conditionToYarn(conditions: NonNullable<ConditionalBlock['condition']>): string {
  return conditions.map(cond => {
    const varName = `$${cond.flag}`;
    
    switch (cond.operator) {
      case 'is_set':
        return varName;
      case 'is_not_set':
        return `not ${varName}`;
      case 'equals':
        return `${varName} == ${formatValue(cond.value)}`;
      case 'not_equals':
        return `${varName} != ${formatValue(cond.value)}`;
      case 'greater_than':
        return `${varName} > ${formatValue(cond.value)}`;
      case 'less_than':
        return `${varName} < ${formatValue(cond.value)}`;
      case 'greater_equal':
        return `${varName} >= ${formatValue(cond.value)}`;
      case 'less_equal':
        return `${varName} <= ${formatValue(cond.value)}`;
      default:
        return varName;
    }
  }).join(' and ');
}

function formatValue(value: any): string {
  if (typeof value === 'string') {
    return `"${value}"`;
  }
  if (typeof value === 'boolean') {
    return value ? 'true' : 'false';
  }
  return String(value);
}

/**
 * Export DialogueTree to Yarn Spinner source
 */
export function exportGraphToYarn(
  tree: DialogueTree,
  options: ExportOptions = {}
): ExportResult {
  const {
    includeLineIds = true,
    includeComments = false,
    indent = '    ',
    ...lineIdOptions
  } = options;
  
  // First ensure all content has line IDs
  const { tree: treeWithIds, lineIdMap } = ensureLineIds(tree, lineIdOptions);
  
  // Create source map
  let sourceMap = createSourceMap(treeWithIds);
  
  const lines: string[] = [];
  
  // Add header comment
  if (includeComments) {
    lines.push(`// Generated by @magicborn/yarn-source`);
    lines.push(`// Title: ${tree.title || 'Untitled'}`);
    lines.push(`// Start Node: ${tree.startNodeId}`);
    lines.push('');
  }
  
  // Export each node
  for (const node of Object.values(treeWithIds.nodes)) {
    lines.push(`title: ${node.id}`);
    lines.push('---');
    
    if (node.type === 'npc') {
      exportNpcNode(node, lines, { includeLineIds, indent, includeComments });
    } else if (node.type === 'player') {
      exportPlayerNode(node, lines, { includeLineIds, indent, includeComments });
    } else if (node.type === 'conditional') {
      exportConditionalNode(node, lines, { includeLineIds, indent, includeComments });
    }
    
    lines.push('===');
    lines.push('');
  }
  
  const yarnSource = lines.join('\n');
  
  // Update source map with yarn line numbers
  sourceMap = updateSourceMapWithYarnLines(sourceMap, yarnSource);
  
  return {
    yarnSource,
    sourceMap,
    lineCount: lines.length,
  };
}

function exportNpcNode(
  node: DialogueNode,
  lines: string[],
  options: { includeLineIds: boolean; indent: string; includeComments: boolean }
): void {
  const { includeLineIds, indent } = options;
  
  // Handle conditional blocks if present
  if (node.conditionalBlocks && node.conditionalBlocks.length > 0) {
    for (const block of node.conditionalBlocks) {
      if (block.type === 'if' || block.type === 'elseif') {
        const condition = block.condition ? conditionToYarn(block.condition) : 'true';
        lines.push(`<<${block.type} ${condition}>>`);
      } else {
        lines.push('<<else>>');
      }
      
      // Block content
      const content = formatDialogueContent(block.content, block.speaker);
      const lineId = block.metadata?.lineId;
      if (lineId && includeLineIds) {
        lines.push(`${content} #line:${lineId}`);
      } else {
        lines.push(content);
      }
      
      // Block next node
      if (block.nextNodeId) {
        lines.push(`<<jump ${block.nextNodeId}>>`);
      }
    }
    lines.push('<<endif>>');
  } else {
    // Regular content
    const content = formatDialogueContent(node.content, node.speaker);
    const lineId = node.metadata?.lineId;
    if (lineId && includeLineIds) {
      lines.push(`${content} #line:${lineId}`);
    } else {
      lines.push(content);
    }
  }
  
  // Set flags
  if (node.setFlags && node.setFlags.length > 0) {
    for (const flag of node.setFlags) {
      lines.push(`<<set $${flag} = true>>`);
    }
  }
  
  // Next node
  if (node.nextNodeId) {
    lines.push(`<<jump ${node.nextNodeId}>>`);
  }
}

function exportPlayerNode(
  node: DialogueNode,
  lines: string[],
  options: { includeLineIds: boolean; indent: string; includeComments: boolean }
): void {
  const { includeLineIds, indent } = options;
  
  if (!node.choices || node.choices.length === 0) {
    return;
  }
  
  for (const choice of node.choices) {
    // Handle conditional choices
    if (choice.conditions && choice.conditions.length > 0) {
      const condition = conditionToYarn(choice.conditions);
      lines.push(`<<if ${condition}>>`);
    }
    
    // Choice line
    const lineId = choice.metadata?.lineId;
    if (lineId && includeLineIds) {
      lines.push(`-> ${choice.text} #line:${lineId}`);
    } else {
      lines.push(`-> ${choice.text}`);
    }
    
    // Choice set flags (indented)
    if (choice.setFlags && choice.setFlags.length > 0) {
      for (const flag of choice.setFlags) {
        lines.push(`${indent}<<set $${flag} = true>>`);
      }
    }
    
    // Choice next node (indented)
    if (choice.nextNodeId) {
      lines.push(`${indent}<<jump ${choice.nextNodeId}>>`);
    }
    
    // Close conditional
    if (choice.conditions && choice.conditions.length > 0) {
      lines.push('<<endif>>');
    }
  }
}

function exportConditionalNode(
  node: DialogueNode,
  lines: string[],
  options: { includeLineIds: boolean; indent: string; includeComments: boolean }
): void {
  const { includeLineIds } = options;
  
  if (!node.conditionalBlocks || node.conditionalBlocks.length === 0) {
    return;
  }
  
  for (const block of node.conditionalBlocks) {
    if (block.type === 'if' || block.type === 'elseif') {
      const condition = block.condition ? conditionToYarn(block.condition) : 'true';
      lines.push(`<<${block.type} ${condition}>>`);
    } else {
      lines.push('<<else>>');
    }
    
    // Block content
    if (block.content) {
      const content = formatDialogueContent(block.content, block.speaker);
      const lineId = block.metadata?.lineId;
      if (lineId && includeLineIds) {
        lines.push(`${content} #line:${lineId}`);
      } else {
        lines.push(content);
      }
    }
    
    // Block next node
    if (block.nextNodeId) {
      lines.push(`<<jump ${block.nextNodeId}>>`);
    }
  }
  
  lines.push('<<endif>>');
  
  // Set flags at node level
  if (node.setFlags && node.setFlags.length > 0) {
    for (const flag of node.setFlags) {
      lines.push(`<<set $${flag} = true>>`);
    }
  }
}

function formatDialogueContent(content: string, speaker?: string): string {
  // Clean up content - remove embedded commands
  let cleanContent = content
    .replace(/<<set\s+\$\w+\s*[+\-*/=]+\s*.+?>>/g, '')
    .trim();
  
  if (speaker) {
    return `${speaker}: ${cleanContent}`;
  }
  return cleanContent;
}

