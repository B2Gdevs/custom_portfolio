---
title: "Book Editor - Next.js Architecture & Considerations"
description: "Running WebSocket server and file uploads in Next.js, pitfalls and solutions"
date: "2025-01-20"
---

# Next.js Architecture & Considerations

## Overview

We're building everything in Next.js, including the WebSocket server and file uploads. This has some challenges but is totally doable.

## WebSocket in Next.js

### The Challenge

Next.js API routes are **request/response** based - they don't maintain persistent connections. WebSockets need **persistent connections**.

### Solutions

#### Option 1: Custom Server (Recommended for Development)

Create a custom Next.js server that handles both HTTP and WebSocket:

```typescript
// server.js (root of project)
const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');
const { WebSocketServer } = require('ws');

const dev = process.env.NODE_ENV !== 'production';
const app = next({ dev });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = createServer((req, res) => {
    const parsedUrl = parse(req.url, true);
    handle(req, res, parsedUrl);
  });

  // WebSocket server on same port
  const wss = new WebSocketServer({ server });

  wss.on('connection', (ws, req) => {
    // Handle WebSocket connections
    const bookId = extractBookId(req.url);
    setupWSConnection(ws, req, { roomName: `book-${bookId}` });
  });

  server.listen(3000, () => {
    console.log('> Ready on http://localhost:3000');
  });
});
```

**Pros:**
- ✅ Works in development
- ✅ Single port
- ✅ Easy to set up

**Cons:**
- ⚠️ Doesn't work with Vercel (serverless)
- ⚠️ Need to use `next start` instead of `next dev`

#### Option 2: Separate WebSocket Server (Production-Ready)

Run WebSocket server separately, Next.js connects to it:

```typescript
// lib/book-editor/websocket/server.ts
// Separate process/port
const wss = new WebSocketServer({ port: 8080 });

// Next.js API route connects to it
// app/api/websocket/route.ts
export async function GET(req: Request) {
  // Proxy to WebSocket server or use Server-Sent Events
}
```

**Pros:**
- ✅ Works with Vercel (can deploy separately)
- ✅ Better scaling
- ✅ Can use Redis for multi-instance

**Cons:**
- ⚠️ More complex setup
- ⚠️ Two ports to manage

#### Option 3: Server-Sent Events (SSE) - Alternative

Use SSE instead of WebSocket (one-way, but simpler):

```typescript
// app/api/events/route.ts
export async function GET(req: Request) {
  const stream = new ReadableStream({
    start(controller) {
      // Send events
      controller.enqueue(`data: ${JSON.stringify(event)}\n\n`);
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
    },
  });
}
```

**Pros:**
- ✅ Works with Next.js API routes
- ✅ Simpler than WebSocket
- ✅ Works with Vercel

**Cons:**
- ⚠️ One-way only (client → server needs separate API calls)
- ⚠️ Less efficient than WebSocket

### Recommendation

**For Development**: Use Option 1 (Custom Server)
- Simple, works locally
- Good for testing

**For Production**: Use Option 2 (Separate Server)
- Deploy WebSocket server separately (Railway, Render, etc.)
- Next.js app connects to it
- Can scale independently

**Hybrid Approach**:
- Development: Custom server (Option 1)
- Production: Separate server (Option 2)
- Use environment variables to switch

## File Uploads in Next.js

### API Route for Uploads

```typescript
// app/api/books/[id]/media/route.ts
import { writeFile } from 'fs/promises';
import { join } from 'path';

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  const formData = await req.formData();
  const file = formData.get('file') as File;

  if (!file) {
    return Response.json({ error: 'No file' }, { status: 400 });
  }

  // No size limit (as requested)
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  // Save to public/books/
  const filename = `${Date.now()}-${file.name}`;
  const path = join(process.cwd(), 'public', 'books', params.id, filename);
  
  await writeFile(path, buffer);

  return Response.json({
    url: `/books/${params.id}/${filename}`,
    filename,
    size: file.size,
  });
}
```

### Considerations

1. **No Size Limits**: 
   - ⚠️ Can fill up disk space
   - ⚠️ Memory issues with very large files
   - ✅ Consider adding warning UI for large files

2. **Storage Location**:
   - `public/books/[bookId]/[filename]`
   - Accessible via URL: `/books/[bookId]/[filename]`

3. **File Types**:
   - Images: jpg, png, gif, webp
   - Media: mp4, webm, mp3
   - Documents: pdf (if needed)

4. **Image Optimization** (Optional):
   ```typescript
   // Can use sharp for optimization
   import sharp from 'sharp';
   const optimized = await sharp(buffer)
     .resize(1920, 1080, { fit: 'inside' })
     .toBuffer();
   ```

## SQLite Authentication

### Simple User System

```typescript
// schema/users.schema.ts
export const users = sqliteTable('users', {
  id: text('id').primaryKey(),
  username: text('username').notNull().unique(),
  email: text('email').notNull().unique(),
  password_hash: text('password_hash').notNull(), // bcrypt
  display_name: text('display_name'),
  avatar_url: text('avatar_url'),
  created_at: integer('created_at', { mode: 'timestamp' }).notNull(),
  last_login: integer('last_login', { mode: 'timestamp' }),
});

// schema/sessions.schema.ts
export const sessions = sqliteTable('sessions', {
  id: text('id').primaryKey(),
  user_id: text('user_id').notNull().references(() => users.id),
  token: text('token').notNull().unique(),
  expires_at: integer('expires_at', { mode: 'timestamp' }).notNull(),
  created_at: integer('created_at', { mode: 'timestamp' }).notNull(),
});
```

### Auth Flow

1. **Register/Login**: Create session token
2. **Store Token**: Cookie or localStorage
3. **Verify Token**: Middleware checks session
4. **User Context**: React context provides current user

### Implementation

```typescript
// lib/auth.ts
export async function login(username: string, password: string) {
  const user = await db.select().from(users).where(eq(users.username, username));
  
  if (!user || !await bcrypt.compare(password, user.password_hash)) {
    throw new Error('Invalid credentials');
  }

  const token = generateToken();
  await db.insert(sessions).values({
    id: crypto.randomUUID(),
    user_id: user.id,
    token,
    expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    created_at: new Date(),
  });

  return { user, token };
}

// middleware.ts (Next.js middleware)
export async function middleware(req: NextRequest) {
  const token = req.cookies.get('session_token')?.value;
  
  if (token) {
    const session = await db.select()
      .from(sessions)
      .where(and(
        eq(sessions.token, token),
        gt(sessions.expires_at, new Date())
      ));
    
    if (session) {
      // User is authenticated
      return NextResponse.next();
    }
  }

  // Redirect to login for protected routes
  if (req.nextUrl.pathname.startsWith('/books/edit')) {
    return NextResponse.redirect(new URL('/login', req.url));
  }
}
```

## Auto-Retry on Save Failures

### Implementation Strategy

```typescript
// hooks/useAutoSave.ts
export function useAutoSave(bookId: string, content: BookContent) {
  const [retryCount, setRetryCount] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [lastError, setLastError] = useState<Error | null>(null);
  const queueRef = useRef<BookContent[]>([]);

  const saveWithRetry = useCallback(async (
    content: BookContent,
    attempt = 1,
    maxRetries = 3
  ) => {
    try {
      setIsSaving(true);
      setLastError(null);
      
      await bookService.saveBook(bookId, content);
      
      // Success - clear queue
      queueRef.current = [];
      setRetryCount(0);
      setIsSaving(false);
    } catch (error) {
      setLastError(error as Error);
      
      if (attempt < maxRetries) {
        // Exponential backoff
        const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
        
        setTimeout(() => {
          saveWithRetry(content, attempt + 1, maxRetries);
        }, delay);
      } else {
        // Max retries reached - queue for later
        queueRef.current.push(content);
        setIsSaving(false);
        
        // Try again after longer delay
        setTimeout(() => {
          if (queueRef.current.length > 0) {
            const queued = queueRef.current.shift()!;
            saveWithRetry(queued, 1, maxRetries);
          }
        }, 30000); // 30 seconds
      }
    }
  }, [bookId, bookService]);

  // Auto-save with debounce
  useEffect(() => {
    const timer = setTimeout(() => {
      saveWithRetry(content);
    }, 5000); // 5 second debounce

    return () => clearTimeout(timer);
  }, [content, saveWithRetry]);

  return { isSaving, lastError, retryCount, manualSave: saveWithRetry };
}
```

### User Feedback

```typescript
// Show save status in UI
{isSaving && <StatusBadge>Saving...</StatusBadge>}
{lastError && (
  <StatusBadge variant="error">
    Save failed. Retrying... ({retryCount}/3)
  </StatusBadge>
)}
```

## Desktop-Only Considerations

### Layout

- **Wide Layouts**: Can use more horizontal space
- **No Touch**: Mouse/keyboard only
- **Larger UI Elements**: Don't need mobile-friendly sizes
- **Fixed Sidebars**: Can have persistent sidebars

### Responsive Strategy

```typescript
// Only optimize for desktop
const styles = {
  container: 'min-w-[1200px]', // Minimum width
  sidebar: 'w-64 fixed', // Fixed sidebar
  editor: 'ml-64', // Account for sidebar
};
```

## Pitfalls & Solutions

### 1. WebSocket with Vercel

**Problem**: Vercel is serverless, no persistent connections

**Solution**: 
- Development: Custom server
- Production: Separate WebSocket server (Railway, Render, etc.)

### 2. File Upload Size

**Problem**: Large files can cause memory issues

**Solution**:
- Stream uploads (don't load entire file in memory)
- Consider chunked uploads for very large files
- Add UI warnings for large files

### 3. SQLite Concurrency

**Problem**: Multiple users editing same book

**Solution**:
- Y.js handles real-time conflicts
- Database writes are queued
- Use transactions for version creation

### 4. Session Management

**Problem**: SQLite sessions need cleanup

**Solution**:
- Cron job to delete expired sessions
- Or cleanup on login/verify

### 5. Production Deployment

**Problem**: Custom server doesn't work with Vercel

**Solution**:
- Deploy Next.js to Vercel
- Deploy WebSocket server separately
- Use environment variables for WebSocket URL

## Recommended Architecture

```
Development:
├── Next.js (Custom Server) - Port 3000
│   ├── HTTP Routes
│   └── WebSocket Server (same port)

Production:
├── Next.js (Vercel) - Port 3000
│   └── HTTP Routes only
└── WebSocket Server (Railway/Render) - Port 8080
    └── Connects to same SQLite DB (or shared DB)
```

## Environment Variables

```env
# Development
NEXT_PUBLIC_WS_URL=ws://localhost:3000

# Production
NEXT_PUBLIC_WS_URL=wss://ws.yourdomain.com
DATABASE_URL=file:./database.db
```

## Summary

- ✅ **WebSocket**: Custom server for dev, separate for production
- ✅ **File Uploads**: Next.js API route, no size limits
- ✅ **Auth**: SQLite-based users and sessions
- ✅ **Auto-Retry**: Exponential backoff with queue
- ✅ **Desktop Only**: Wide layouts, fixed sidebars
- ✅ **EPUB Export**: Standard format

This architecture works well for development and can scale to production when needed.




